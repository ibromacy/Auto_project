name: dbt CI — Auto Project

on:
  pull_request:
    branches:
      - main
    paths:
      - 'models/**'
      - 'tests/**'
      - 'macros/**'
      - 'snapshots/**'
      - 'dbt_project.yml'

jobs:
  dbt-ci:
    name: Run dbt build on modified models
    runs-on: ubuntu-latest

    env:
      DBT_PROFILES_DIR: ./

    steps:

      # ── 1. Checkout the code ───────────────────────────────────────────
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # needed for dbt state comparison (modified models)

      # ── 2. Set up Python ───────────────────────────────────────────────
      - name: Set up Python 3.11
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      # ── 3. Install dbt-snowflake ───────────────────────────────────────
      - name: Install dbt-snowflake
        run: |
          pip install --upgrade pip
          pip install dbt-snowflake==1.9.0

      # ── 4. Write the private key from GitHub Secrets to a temp file ────
      #
      #  Your local profiles.yml uses a file path for the private key.
      #  GitHub Actions has no access to your machine, so we write the
      #  key content (stored as a GitHub Secret) to a temp file at runtime
      #  and point the CI profiles.yml at that path.
      #
      - name: Write Snowflake private key to file
        run: |
          echo "${{ secrets.SNOWFLAKE_PRIVATE_KEY }}" > /tmp/snowflake_key.p8
          chmod 600 /tmp/snowflake_key.p8

      # ── 5. Write CI-specific profiles.yml ─────────────────────────────
      #
      #  We write a fresh profiles.yml at runtime using GitHub Secrets.
      #  This replaces the local path-based key with the temp file above.
      #  Your committed profiles.yml is NOT used in CI — this one is.
      #
      - name: Write dbt profiles.yml for CI
        run: |
          cat > profiles.yml << EOF
          Auto_project:
            target: dev
            outputs:
              dev:
                type: snowflake
                account: ${{ secrets.SNOWFLAKE_ACCOUNT }}
                user: ${{ secrets.SNOWFLAKE_USER }}
                private_key_path: /tmp/snowflake_key.p8
                role: AUTO_ROLE
                database: AUTO_DB
                warehouse: COMPUTE_WH
                schema: AUTO_SCHEMA_CI
                threads: 4
          EOF

      # ── 6. Verify dbt can connect to Snowflake ─────────────────────────
      - name: dbt debug (connection check)
        run: dbt debug

      # ── 7. Fetch the production manifest for state comparison ──────────
      #
      #  dbt --select state:modified+ only works if it has a previous
      #  manifest to compare against. We download the latest manifest
      #  from the main branch artifact (uploaded in step 10 on each run).
      #
      #  On the very first CI run there will be no artifact yet —
      #  the fallback in step 8 handles this by running dbt build on
      #  all models instead.
      #
      - name: Download previous manifest (for state comparison)
        uses: dawidd6/action-download-artifact@v6
        with:
          name: dbt-manifest
          branch: main
          workflow: dbt_ci.yml
          path: ./previous_state
        continue-on-error: true  # first run has no previous manifest — that's fine

      # ── 8. Run dbt build on modified models + their downstream deps ────
      #
      #  If a previous manifest exists: build only changed models + downstream.
      #  If no previous manifest (first run): build all models.
      #
      #  schema: AUTO_SCHEMA_CI keeps CI output separate from your dev schema.
      #  Nothing CI writes will touch your real data.
      #
      - name: dbt build (modified models + downstream)
        run: |
          if [ -f ./previous_state/manifest.json ]; then
            echo "Previous manifest found — running on modified models only"
            dbt build \
              --select state:modified+ \
              --state ./previous_state \
              --target dev
          else
            echo "No previous manifest — running full build on first CI run"
            dbt build \
              --target dev
          fi

      # ── 9. Upload the fresh manifest as an artifact ────────────────────
      #
      #  This manifest becomes the "previous state" for the next PR.
      #  Retained for 30 days.
      #
      - name: Upload dbt manifest artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: dbt-manifest
          path: ./target/manifest.json
          retention-days: 30

      # ── 10. Post a summary to the PR ──────────────────────────────────
      - name: Write job summary
        if: always()
        run: |
          echo "## dbt CI Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Detail | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|---|---|" >> $GITHUB_STEP_SUMMARY
          echo "| Project | Auto_project |" >> $GITHUB_STEP_SUMMARY
          echo "| Target | dev |" >> $GITHUB_STEP_SUMMARY
          echo "| Schema | AUTO_SCHEMA_CI (isolated from dev) |" >> $GITHUB_STEP_SUMMARY
          echo "| Trigger | PR → main |" >> $GITHUB_STEP_SUMMARY
          echo "| Branch | ${{ github.head_ref }} |" >> $GITHUB_STEP_SUMMARY
